/****************************************************************************
*
*					SciTech Multi-platform Graphics Library
*
*  ========================================================================
*
*    The contents of this file are subject to the SciTech MGL Public
*    License Version 1.0 (the "License"); you may not use this file
*    except in compliance with the License. You may obtain a copy of
*    the License at http://www.scitechsoft.com/mgl-license.txt
*
*    Software distributed under the License is distributed on an
*    "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
*    implied. See the License for the specific language governing
*    rights and limitations under the License.
*
*    The Original Code is Copyright (C) 1991-1998 SciTech Software, Inc.
*
*    The Initial Developer of the Original Code is SciTech Software, Inc.
*    All Rights Reserved.
*
*  ========================================================================
*
* Language:		ANSI C
* Environment:	Any
*
* Description:  Display a number of random rectangles with random
*               attributes clipping them with clip regions.
*
****************************************************************************/

#include <string.h>
#include "mglsamp.h"
#include "pattern.h"

#define IMAGE_NAME "frog-8.bmp"
#define IMAGE_NAME2 "doggie2.bmp"
#define MAX_LINES 35

#define logoByteWidth 41
static uchar logoMSB[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0x80,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xDF,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x87,0x80,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x03,0xC0,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x01,0xE0,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x3F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFE,0x00,0xF0,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x3F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFC,0x00,0xF8,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x3F,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x01,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xF8,0x03,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x03,0xE0,0x00,0x00,0x00,0xFF,0xFC,0x7F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x07,0xE0,0x00,0x00,0x00,0x7F,0xF0,0x1F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xE0,0x0F,0xC0,0x00,0x00,0x00,0x7F,0xC0,0x0F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x0F,0x80,0x00,0x00,0x00,0x3F,0x00,0x01,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xC0,0x1F,0x80,0x00,0x00,0x00,0x1F,0x80,0x00,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x0D,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0x80,0x1F,0x00,0x00,0x00,0x00,0x0F,0xC0,0x00,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x80,0x3F,0x00,0x00,0x00,0x00,0x07,0xF0,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x0E,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x00,0x7E,0x00,0x00,0x00,0x00,0x03,0xF8,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x0E,0x7F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x00,0x7C,0x00,0x00,0x00,0x00,0x01,0xFE,0x03,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x0E,0x7F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFE,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x06,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFC,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x07,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x01,0xF0,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x07,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x8F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x8F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x8F,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x0F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x87,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC7,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC3,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0x80,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC1,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x80,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE1,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE0,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFE,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFC,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFC,0x01,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFE,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x3F,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x1F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xC7,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x0F,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xEF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x0F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x0F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x07,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x03,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x01,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x01,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x01,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x01,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x03,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x07,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0F,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
    0x00,0x1F,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x1F,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x7F,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7F,0xFE,0x07,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0xFF,0xFC,0x01,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0xFF,0xF8,0x01,0xFF,0xF8,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0xFF,0xF8,0x00,0xFF,0xFC,0x00,0x00,0x07,0xFF,0xF8,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x7F,0xFC,0x00,0x00,0x00,0x00,0x00,0x7F,0xF8,0x00,0x00,0x03,0xFF,0xC0,0x7F,0xF0,0x00,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0xFF,0xFC,0x00,0x00,0x1F,0xFF,0xFC,0x00,0x00,0x3F,0xFC,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xFF,0x80,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x03,0xFF,0xC1,0xFF,0xF8,0x00,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0x7F,0xFC,0x00,0x00,0xFF,0xFF,0xFF,0x80,0x00,0x3F,0xFC,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x0F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xE0,0x00,0x03,0xFF,0xC7,0xFF,0xFF,0x00,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0x3F,0xF8,0x00,0x03,0xFF,0xFF,0xFF,0xE0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x00,0x03,0xFF,0xCF,0xFF,0xFF,0xC0,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xF0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,
    0x00,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,
    0x00,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0x80,0x03,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,
    0x00,0xFF,0xFC,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,
    0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,
    0x00,0x7F,0xFF,0x80,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,
    0x00,0x3F,0xFF,0xF8,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xF8,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0x00,0x00,0x03,0xFF,0xFF,0x80,0xFF,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x3F,0xFF,0xF8,0x3F,0xFF,0xF8,0x00,0x3F,0xFF,0xFE,0x7F,0xFF,0xF8,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0xC0,0x00,0x03,0xFF,0xFE,0x00,0x3F,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0xE0,0x0F,0xFF,0xFC,0x00,0x7F,0xFF,0xE0,0x0F,0xFF,0xFC,0x03,0xFF,0xFF,0x81,0xFF,0xFF,0x00,0x00,
    0x00,0x1F,0xFF,0xFF,0xF0,0x00,0x07,0xFF,0xF8,0x00,0x0F,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0x00,0x01,0xFF,0xFC,0x00,0x7F,0xFF,0x80,0x03,0xFF,0xFE,0x03,0xFF,0xFC,0x00,0x3F,0xFF,0x80,0x00,
    0x00,0x0F,0xFF,0xFF,0xFC,0x00,0x07,0xFF,0xE0,0x00,0x07,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFE,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFE,0x00,0x00,0xFF,0xFE,0x03,0xFF,0xF8,0x00,0x1F,0xFF,0x80,0x00,
    0x00,0x07,0xFF,0xFF,0xFE,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFF,0x03,0xFF,0xF0,0x00,0x0F,0xFF,0x80,0x00,
    0x00,0x03,0xFF,0xFF,0xFF,0x80,0x0F,0xFF,0xC0,0x00,0x01,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF0,0x00,0x00,0x1F,0xFE,0x01,0xFF,0xF8,0x00,0x00,0x3F,0xFF,0x03,0xFF,0xF0,0x00,0x0F,0xFF,0xC0,0x00,
    0x00,0x01,0xFF,0xFF,0xFF,0xC0,0x0F,0xFF,0x80,0x00,0x00,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF0,0x00,0x00,0x1F,0xFF,0x01,0xFF,0xF0,0x00,0x00,0x3F,0xFF,0x03,0xFF,0xE0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x7F,0xFF,0xFF,0xE0,0x1F,0xFF,0x80,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xE0,0x00,0x00,0x0F,0xFF,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x03,0xFF,0xE0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x1F,0xFF,0xFF,0xF0,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xE0,0x00,0x00,0x0F,0xFF,0x01,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x03,0xFF,0xFF,0xF0,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x7F,0xFF,0xF8,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x1F,0xFF,0xF8,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x07,0xFF,0xFC,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x01,0xFF,0xFC,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0xFF,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x7F,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x3F,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x3F,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x1F,0xFE,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x1F,0xFE,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xC0,0x00,0x1F,0xFE,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xE0,0x00,0x00,0x00,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xC0,0x00,0x1F,0xFE,0x0F,0xFF,0x80,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xF0,0x00,0x00,0x00,0x00,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xE0,0x00,0x3F,0xFE,0x0F,0xFF,0xC0,0x00,0x00,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xE0,0x00,0x3F,0xFE,0x07,0xFF,0xE0,0x00,0x01,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF8,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x3F,0xFF,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x03,0xFF,0xE0,0x00,0x3F,0xFE,0x07,0xFF,0xF0,0x00,0x03,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFF,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
	0x03,0xFF,0xF0,0x00,0x7F,0xFC,0x07,0xFF,0xF8,0x00,0x07,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFE,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFE,0x00,0x00,0xFF,0xFE,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x03,0xFF,0xFC,0x01,0xFF,0xFC,0x03,0xFF,0xFE,0x00,0x1F,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0x80,0x01,0xFF,0xFC,0x00,0x7F,0xFF,0x80,0x01,0xFF,0xFE,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x01,0xFF,0xFF,0x07,0xFF,0xFC,0x01,0xFF,0xFF,0x80,0xFF,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0xE0,0x0F,0xFF,0xFC,0x00,0x7F,0xFF,0xF0,0x0F,0xFF,0xFC,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xFC,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF8,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0x80,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
	0x00,0x7F,0xFF,0xFF,0xFF,0xE0,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x3F,0xFF,0xFF,0xFF,0xE0,0x00,0x1F,0xFF,0xFF,0xFF,0xFE,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xC0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x1F,0xFF,0xFF,0xFF,0xC0,0x00,0x0F,0xFF,0xFF,0xFF,0xFC,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xC0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x0F,0xFF,0xFF,0xFF,0x80,0x00,0x07,0xFF,0xFF,0xFF,0xF8,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x07,0xFF,0xFF,0xFE,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xE0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x03,0xFF,0xFF,0xFC,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xC0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x0F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xF0,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x1F,0xFF,0xC0,0x00,0x00,0x00,0x07,0xFF,0xFC,0x00,0x00,0x1F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x03,0xFF,0xFF,0x80,0x00,0x00,0x00,0x03,0xFF,0xFF,0xC0,0x00,0x03,0xFF,0xC0,0x00,0x03,0xFF,0xC0,0x00,
    0x00,0x00,0x07,0xFE,0x00,0x00,0x00,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFC,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,
    0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,
    0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,
    0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0xF0,0x00,0x00,0x3E,0x00,0x00,0x0F,0xE0,0x00,0x7F,0xC0,0x00,0x80,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0xF8,0x00,0x01,0xFF,0x80,0x00,0x1F,0xE0,0x00,0x7F,0xC0,0x00,0xC0,0xC0,0xC0,0x00,0x0E,0x00,0x00,0x0F,0xF0,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0xC0,0x60,0x00,0x01,0xFC,0x00,0x00,
    0x07,0x18,0x00,0x03,0x83,0xC0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0xE0,0xE0,0xC0,0x00,0x0F,0x00,0x00,0x0E,0x9C,0x00,0x03,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x01,0xC0,0x60,0x00,0x07,0xFF,0x00,0x00,
    0x07,0x08,0x00,0x03,0x00,0xE0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x60,0xE0,0x80,0x00,0x0F,0x80,0x00,0x0C,0x0C,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0xE0,0x60,0x00,0x07,0x07,0x00,0x00,
    0x07,0x00,0x00,0x06,0x00,0x60,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x61,0xE1,0x80,0x00,0x19,0x80,0x00,0x0C,0x0E,0x00,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x06,0x00,0x01,0xF0,0x60,0x00,0x0C,0x01,0x80,0x00,
    0x07,0x00,0x00,0x06,0x00,0x30,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x61,0xE1,0x80,0x00,0x19,0x80,0x00,0x0C,0x0E,0x00,0x03,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x06,0x00,0x01,0xB8,0x60,0x00,0x18,0x00,0x00,0x00,
    0x03,0xE0,0x00,0x06,0x00,0x30,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x63,0xF1,0x80,0x00,0x11,0xC0,0x00,0x0C,0x0E,0x00,0x03,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x06,0x00,0x01,0xB8,0x60,0x00,0x18,0x00,0x00,0x00,
    0x00,0xF8,0x00,0x0C,0x00,0x30,0x00,0x1F,0xE0,0x00,0x06,0x00,0x00,0x73,0x33,0x80,0x00,0x30,0xC0,0x00,0x0C,0x1C,0x00,0x03,0xFC,0x00,0x00,0x01,0xFC,0x00,0x00,0x06,0x00,0x01,0x9C,0x60,0x00,0x18,0x00,0x00,0x00,
    0x00,0x38,0x00,0x0E,0x00,0x30,0x00,0x1F,0xE0,0x00,0x06,0x00,0x00,0x33,0x13,0x00,0x00,0x70,0xE0,0x00,0x0D,0xFC,0x00,0x03,0xFC,0x00,0x00,0x03,0xFE,0x00,0x00,0x06,0x00,0x01,0x8E,0x60,0x00,0x18,0x00,0x00,0x00,
    0x00,0x0C,0x00,0x06,0x00,0x30,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x33,0x13,0x00,0x00,0x7F,0xE0,0x00,0x0C,0xF0,0x00,0x03,0x00,0x00,0x00,0x01,0xFC,0x00,0x00,0x06,0x00,0x01,0x86,0x60,0x00,0x18,0x00,0x00,0x00,
    0x06,0x0C,0x00,0x07,0x00,0x60,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1F,0x1B,0x00,0x00,0x60,0x70,0x00,0x0C,0xE0,0x00,0x03,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x06,0x00,0x01,0x83,0x60,0x00,0x18,0x00,0x00,0x00,
    0x06,0x0C,0x00,0x07,0x00,0xE0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1E,0x1E,0x00,0x00,0xC0,0x70,0x00,0x0C,0x70,0x00,0x03,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x06,0x00,0x01,0x83,0xE0,0x00,0x1C,0x00,0x80,0x00,
    0x07,0x18,0x00,0x03,0xC1,0xC0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1E,0x1E,0x00,0x00,0xC0,0x30,0x00,0x0C,0x30,0x00,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x06,0x00,0x01,0x81,0xE0,0x00,0x0E,0x03,0x80,0x00,
	0x03,0xF8,0x00,0x01,0xFF,0x80,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1E,0x1E,0x00,0x01,0x80,0x18,0x00,0x0C,0x18,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0x81,0xE0,0x00,0x07,0x07,0x00,0x00,
	0x01,0xF0,0x00,0x00,0x7F,0x00,0x00,0x0C,0x00,0x00,0x06,0x00,0x00,0x1C,0x0E,0x00,0x01,0x80,0x18,0x00,0x0C,0x1C,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0x80,0xE0,0x00,0x07,0xFE,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x60,0x00,0x00,0xF8,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};
static int logoHeight = sizeof(logoMSB)/logoByteWidth;

typedef struct {
	point_t p1,p2;
	point_t d1,d2;
	int color;
} vector;

/*----------------------------- Global Variables --------------------------*/

char demoName[] = "cliprgn";

/*------------------------------ Implementation ---------------------------*/

ibool rectTest(MGLDC *dc, region_t *region)
{
	int     maxx,maxy,val;
	rect_t  r;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Rectangle Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();
	while (!checkEvent()) {
		r.left = MGL_random(maxx);
		r.right = MGL_random(maxx);
		r.top = MGL_random(maxy);
		r.bottom = MGL_random(maxy);

		/* Fix the rectangle so it is not empty */

		if (r.right < r.left)
			SWAP(r.left,r.right);
		if (r.bottom < r.top)
			SWAP(r.top,r.bottom);

		MGL_setColor(randomColor());
		MGL_setBackColor(randomColor());

		if ((val = MGL_random(3)) == 0) {
			MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
			MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
			MGL_usePenBitmapPattern(0);
			}
		else if (val == 1) {
			MGL_setPenStyle(MGL_BITMAP_OPAQUE);
			MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
			MGL_usePenBitmapPattern(0);
			}
		else {
			MGL_setPenStyle(MGL_BITMAP_SOLID);
			}

		MGL_fillRect(r);
		}
	defaultAttributes(dc);
    return (pause());
}

ibool lineTest(MGLDC *dc, region_t *region)
/****************************************************************************
*
* Function:     lineTest
* Parameters:   dc     		- Display dc
*
* Description:  Draw solid lines and how andchange thier color.
*
****************************************************************************/
{
	int i,lines,maxx,maxy;
	vector *v;

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	lines = ((float)MAX_LINES/maxy)*maxy;

	v = (vector *)MGL_malloc(sizeof(vector)*lines);

	for(i=0;i<lines;i++) {
        v[i].p1.x = i*(maxx/MAX_LINES);
        v[i].p1.y = i*(maxy/MAX_LINES);
        v[i].p2.x = maxx - i*(maxx/MAX_LINES);
        v[i].p2.y = i*(maxy/MAX_LINES);
		v[i].d1.x = 1;
		v[i].d1.y = -1;
		v[i].d2.x = -1;
		v[i].d2.y = 1;
        v[i].color = randomColor();
	}

	/* Display title message at the top of the window. */
	mainWindow(dc,"Line Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	MGL_setBackColor(MGL_LIGHTGRAY);
	MGL_clearViewport();
	MGL_setColor(MGL_GREEN);
	MGL_drawRegion(0,0,region);
	MGL_setClipRegion(region);

	MGL_setPenStyle(MGL_BITMAP_SOLID);
	while (!checkEvent()) {
		for(i=0;i<lines;i++) {
			/* change the position of both vertices */
			v[i].p1.x += v[i].d1.x;
			v[i].p1.y += v[i].d1.y;
			v[i].p2.x += v[i].d2.x;
			v[i].p2.y += v[i].d2.y;

			/* change the direction of the first vertice */
			if (v[i].p1.x>maxx) v[i].d1.x = -1;
			if (v[i].p1.x<=0) v[i].d1.x = 1;
			if (v[i].p1.y>maxy) v[i].d1.y = -1;
			if (v[i].p1.y<=0) v[i].d1.y = 1;

			/* change the direction of the second vertice */
			if (v[i].p2.x>maxx) v[i].d2.x = -1;
			if (v[i].p2.x<=0) v[i].d2.x = 1;
			if (v[i].p2.y>maxy) v[i].d2.y = -1;
			if (v[i].p2.y<=0) v[i].d2.y = 1;

			MGL_setColor(v[i].color);
			MGL_line(v[i].p1,v[i].p2);
			}
		}

	MGL_free(v);
	defaultAttributes(dc);
    return (pause());
}

ibool pixelDemo(MGLDC *dc, region_t *region)
/****************************************************************************
*
* Function:     pixelDemo
* Parameters:   dc  - Device context
*
* Description:  Display a pattern of random dots on the screen and
*               pick them back up again.
*
****************************************************************************/
{
	int     seed = 1958;
	int     x,y,maxx,maxy;

	mainWindow(dc,"MGL_pixel Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_srand(seed);        /* Seed random number gen with known value  */

	MGL_beginPixel();
	while (!checkEvent()) {
		x = 1 + MGL_random(maxx);       /* Generate a random location   */
		y = 1 + MGL_random(maxy);
		MGL_setColor(randomColor());
		MGL_pixelCoord(x,y);
		}
	MGL_setColor(MGL_defaultColor());
    return(pause());
}

ibool sysBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int x,y,maxx,maxy;
	palette_t pal[256];
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *memdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"System BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	if (MGL_getBitsPerPixel(dc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memory device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
		}

	rect.right = width;
	rect.bottom = height;

	while (!checkEvent()) {
		x = MGL_random(maxx-width);
		y = MGL_random(maxy-height);
		/* Copy image from image in memory to the screen. */
		MGL_bitBlt(dc,memdc,rect,x,y,MGL_REPLACE_MODE);
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool screenBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth,maxx,maxy;
	palette_t pal[256];
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *memdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Screen to Screen BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	if (MGL_getBitsPerPixel(dc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memory device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
		}

	rect.right = width;
	rect.bottom = height;
	/* Copy image from image in memory to the screen. */
	MGL_bitBlt(dc,memdc,rect,50,50,MGL_REPLACE_MODE);

	MGL_bitBlt(dc,dc,rect,127,200,MGL_REPLACE_MODE);
	MGL_bitBlt(dc,dc,rect,408,100,MGL_REPLACE_MODE);
	MGL_bitBlt(dc,dc,rect,190,325,MGL_REPLACE_MODE);
	MGL_bitBlt(dc,dc,rect,280,0,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool offScreenBltDemo(MGLDC *dc, region_t *region)
{
	// TODO: implement this!
#if 0
	int x,y,width,height,depth,maxx,maxy;
	palette_t pal[256];
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *offdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Offscreen BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	if (MGL_getBitsPerPixel(dc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((offdc = MGL_createOffscreenDC()) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memory device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(offdc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(offdc,pal,MGL_getPaletteSize(offdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(offdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(offdc),0,true);
		}

	rect.right = width;
	rect.bottom = height;

	while (!checkEvent()) {
		x = MGL_random(maxx-width);
		y = MGL_random(maxy-height);
		/* Copy image from image in memory to the screen. */
		MGL_bitBlt(dc,offdc,rect,x,y,MGL_REPLACE_MODE);
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(offdc);
	defaultAttributes(dc);
    return(pause());
#else
    return true;  
#endif
}

ibool srcBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int x,y,maxx,maxy;
	palette_t pal[256];
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *memdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Memory Source BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	if (MGL_getBitsPerPixel(dc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memory device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
		}

	rect.right = width;
	rect.bottom = height;

	while (!checkEvent()) {
		x = MGL_random(maxx-width);
		y = MGL_random(maxy-height);
		/* Copy image from image in memory to the screen. */
		MGL_bitBlt(dc,memdc,rect,x,y,MGL_REPLACE_MODE);
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool srcTranslationBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int x,y,maxx,maxy;
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *memdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Memory Source Translated BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	if (MGL_getBitsPerPixel(dc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memory device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	rect.right = width-50;
	rect.bottom = height-50;

	while (!checkEvent()) {
		x = MGL_random(maxx-width);
		y = MGL_random(maxy-height);
		/* Copy image from image in memory to the screen. */
		MGL_bitBlt(dc,memdc,rect,x,y,MGL_REPLACE_MODE);
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool dstBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int maxx,maxy;
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *memdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Memory Destination BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));
	MGL_setDefaultPalette(memdc);
	MGL_realizePalette(memdc,MGL_getPaletteSize(memdc),0,true);

	/* Load a bitmap onto the screen device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(dc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	MGL_makeCurrentDC(memdc);

	/* Fill memDC with solid color */
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setClipRegionDC(memdc,region);

	if (MGL_getBitsPerPixel(memdc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	MGL_makeCurrentDC(dc);

	rect.left = 0;
	rect.top = 0;
	rect.right = maxx+1;
	rect.bottom = maxy+1;
	/* Copy image from the screen to memory. */
	MGL_bitBlt(memdc,dc,rect,0,0,MGL_REPLACE_MODE);

	/* Reset Clipping Rectangle to entire viewport. */
	MGL_setClipRegionDC(memdc,MGL_rgnSolidRectCoord(0,0,maxx+1,maxy+1));

	/* Copy image from memory to the screen. */
	MGL_bitBlt(dc,memdc,rect,0,0,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool dstTranslationBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int maxx,maxy;
	rect_t rect = {0};
	pixel_format_t pf;
	MGLDC *memdc;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Memory Destination Translated BitBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));
	MGL_setDefaultPalette(memdc);
	MGL_realizePalette(memdc,MGL_getPaletteSize(memdc),0,true);

	/* Load a bitmap onto the screen device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(dc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	MGL_makeCurrentDC(memdc);

	/* Fill memDC with solid color */
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setClipRegionDC(memdc,region);

	if (MGL_getBitsPerPixel(memdc) <= 8)
		MGL_setColor(2);
	else
		MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,region);

	MGL_makeCurrentDC(dc);

	rect.left = 0;
	rect.top = 0;
	rect.right = maxx+1;
	rect.bottom = maxy+1;
	/* Copy image from the screen to memory. */
	MGL_bitBlt(memdc,dc,rect,0,0,MGL_REPLACE_MODE);

	/* Reset Clipping Rectangle to entire viewport. */
	MGL_setClipRegionDC(memdc,MGL_rgnSolidRectCoord(0,0,maxx+1,maxy+1));

	/* Copy image from memory to the screen. */
	MGL_bitBlt(dc,memdc,rect,0,0,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool srcTransOffBltDemo(MGLDC *dc, region_t *region)
{
	// TODO: implement this!
#if 0
	int width,height,depth;
	int maxx,maxy;
	MGLDC *offdc;
	pixel_format_t pf;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Source Transparency Offscreen Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	offdc = MGL_createOffscreenDC();
	/* Load a bitmap into the offscreen device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Get transparent color from pixel (0,0) */
	MGL_makeCurrentDC(offdc);
	transparent = MGL_getPixelCoord(0,0);
	MGL_makeCurrentDC(dc);
	MGL_setClipRegion(region);

	/* Copy image from offscreen video memory to the screen. */
	while (!checkEvent())
		MGL_srcTransBltCoord(dc,offdc,0,0,width,height,MGL_random(maxx+1),MGL_random(maxy+1),transparent,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(offdc);
	defaultAttributes(dc);

    return(pause());
#else
    return true;  
#endif
}

ibool dstTransOffBltDemo(MGLDC *dc, region_t *region)
{
	// TODO: implement this!
#if 0
	int width,height,depth;
	int maxx,maxy;
	MGLDC *offdc;
	pixel_format_t pf;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Destination Transparency Offscreen Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	offdc = MGL_createOffscreenDC();
	MGL_makeCurrentDC(offdc);

	/* Fill offDC with solid color */
	MGL_setBackColor(MGL_RED);
	MGL_fillRectCoord(0,0,maxx+1,maxy+1);

	/* Load a bitmap into the offscreen device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Get transparent color from pixel (0,0) */
	transparent = MGL_getPixelCoord(0,0);

	/* Fill offDC with solid color */
	MGL_setBackColor(MGL_RED);
	MGL_fillRectCoord(0,0,maxx+1,maxy+1);

	MGL_makeCurrentDC(dc);
	MGL_setBackColor(transparent);
	MGL_clearDevice();
	MGL_setClipRegion(region);

	/* Copy image from offscreen video memory to the screen. */
	MGL_dstTransBltCoord(dc,offdc,0,0,maxx,maxy,0,0,transparent,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(offdc);
	defaultAttributes(dc);
    return(pause());

#else
    return true;  
#endif
    
}

ibool srcTransBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int maxx,maxy;
	palette_t pal[256];
	MGLDC *memdc;
	pixel_format_t pf;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Source Transparency Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memorty device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Get transparent color from pixel (0,0) */
	MGL_makeCurrentDC(memdc);
	transparent = MGL_getPixelCoord(0,0);
	MGL_makeCurrentDC(dc);
	MGL_setClipRegion(region);

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
		}

	/* Copy image from offscreen video memory to the screen. */
	while (!checkEvent())
		MGL_srcTransBltCoord(dc,memdc,0,0,width,height,MGL_random(maxx+1),MGL_random(maxy+1),transparent,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool dstTransBltDemo(MGLDC *dc, region_t *region)
{
	int width,height,depth;
	int maxx,maxy;
	palette_t pal[256];
	MGLDC *memdc;
	pixel_format_t pf;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Destination Transparency Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));
	MGL_makeCurrentDC(memdc);

	/* Fill memdc with solid color */
	MGL_setBackColor(MGL_RED);
	MGL_fillRectCoord(0,0,maxx+1,maxy+1);

	/* Load a bitmap into the offscreen device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Get transparent color from pixel (0,0) */
	transparent = MGL_getPixelCoord(0,0);

	MGL_makeCurrentDC(dc);
	MGL_setBackColor(transparent);
	MGL_clearDevice();
	MGL_setClipRegion(region);

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
		}

	/* Copy image from offscreen video memory to the screen. */
	MGL_dstTransBltCoord(dc,memdc,0,0,maxx,maxy,0,0,transparent,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);
	defaultAttributes(dc);
    return(pause());
}

ibool linBltDemo(MGLDC *dc, region_t *region)
{
	// TODO: Implement this!
#if 0
	int x,y,width,height,depth;
	int maxx,maxy;
	MGLDC *offdc;
	pixel_format_t pf;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Linear Offscreen Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	offdc = MGL_createLinearOffscreenDC();

	/* Load a bitmap into the offscreen device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	MGL_setClipRegion(region);

	/* Copy image from offscreen video memory to the screen. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_bitBltLinCoord(dc,offdc,0,dc->mi.bytesPerLine,x,y,x+width-1,y+height-1,MGL_REPLACE_MODE);
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(offdc);
	defaultAttributes(dc);
    return(pause());
#else
    return true;  
#endif

}

ibool srcTransLinBltDemo(MGLDC *dc, region_t *region)
{
	// TODO: Implement this!
#if 0
	int x,y,width,height,depth;
	int maxx,maxy;
	MGLDC *offdc;
	pixel_format_t pf;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Source Transparency Linear Offscreen Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	offdc = MGL_createLinearOffscreenDC();
	/* Load a bitmap into the offscreen device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Get transparent color from pixel (0,0) */
	MGL_makeCurrentDC(offdc);
	transparent = MGL_getPixelCoord(0,0);
	MGL_makeCurrentDC(dc);

	MGL_setClipRegion(region);

	/* Copy image from offscreen video memory to the screen. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_srcTransBltLinCoord(dc,offdc,0,dc->mi.bytesPerLine,x,y,x+width-1,y+height-1,transparent,MGL_REPLACE_MODE);
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(offdc);
	defaultAttributes(dc);
    return(pause());
#else
    return true;  
#endif

}

ibool dstTransLinBltDemo(MGLDC *dc, region_t *region)
{
	// TODO: Implement this!
#if 0
	int width,height,depth;
	int maxx,maxy;
	palette_t pal[256];
	MGLDC *offdc;
	pixel_format_t pf;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Destination Transparency Linear Offscreen Memory Accelerated Blit Demo");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf);

	offdc = MGL_createLinearOffscreenDC();
	MGL_makeCurrentDC(offdc);

	/* Fill offdc with solid color */
	MGL_setBackColor(MGL_RED);
	MGL_fillRectCoord(0,0,maxx+1,maxy+1);

	/* Load a bitmap into the offscreen device context. The palette gets
	 * realized as well.
	 */
	if (MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Get transparent color from pixel (0,0) */
	transparent = MGL_getPixelCoord(0,0);

	MGL_makeCurrentDC(dc);
	MGL_setBackColor(transparent);
	MGL_clearDevice();
	MGL_setClipRegion(region);

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	if (depth <= 8) {
		MGL_getPalette(offdc,pal,MGL_getPaletteSize(offdc),0);
		MGL_setPalette(dc,pal,MGL_getPaletteSize(offdc),0);
		MGL_realizePalette(dc,MGL_getPaletteSize(offdc),0,true);
		}

	/* Copy image from offscreen video memory to the screen. */
	MGL_dstTransBltLinCoord(dc,offdc,0,dc->mi.bytesPerLine,0,0,width-1,height-1,transparent,MGL_REPLACE_MODE);

	/* Remove all device contexts from memory. */
	MGL_destroyDC(offdc);
	defaultAttributes(dc);
    return(pause());
#else
    return true;  
#endif

}

ibool textDemo(MGLDC *dc, region_t *region)
{
	int         i,maxx;
	font_t      *font;
	char        buf[80];

	maxx = MGL_maxx();

	strcpy(buf,"helv38.fnt");
	font = MGL_loadFont(buf);
	err = MGL_result();
	if (err == grFontNotFound)
        return true;
	if ((err = MGL_result()) != grOK) {
		MGL_exit();
		exit(1);
		}
	sprintf(buf,"Bitmap Font: '%s' - %d Point", font->name, font->pointSize);
	mainWindow(dc,buf);
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setClipRegion(region);

	/* Display all characters on the screen */
	MGL_useFont(font);
	buf[1] = '\0';
	for (i = ' '; i < 256; i++) {
		buf[0] = i;
		MGL_drawStr(buf);
		if (MGL_getX() + MGL_maxCharWidth() > maxx) {
			MGL_moveToCoord(0,MGL_getY() + MGL_textHeight());
			}
		}
	for (i = ' '; i < 256; i++) {
		buf[0] = i;
		MGL_drawStr(buf);
		if (MGL_getX() + MGL_maxCharWidth() > maxx) {
			MGL_moveToCoord(0,MGL_getY() + MGL_textHeight());
			}
		}

	/* Unload the font from memory */
	MGL_unloadFont(font);
	MGL_useFont(defFont);
	defaultAttributes(dc);

    return(pause());
}

ibool monoImageDemo(MGLDC *dc, region_t *region)
{
	int i,x,y,maxx,maxy;

	/* Display title message at the top of the window. */
	mainWindow(dc,"Monochrome Image BltBlt Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);
	MGL_setClipRegion(region);
	MGL_setColor(MGL_GREEN);
	for (i = 0; i < 25; i++) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putMonoImage(dc,x,y,logoByteWidth<<3,logoByteWidth,logoHeight,(void *)&logoMSB);
		}

	defaultAttributes(dc);
    return(pause());
}

ibool bitmapDemo1(MGLDC *dc, region_t *region)
{
	int i,x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmap (Monochrome Image) Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setClipRegion(region);

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadPNG("cow-1.png",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Justify the image that will be put on the screen */
	x = (MGL_sizex(dc)-bitmap->width)/2;
	y = (MGL_sizey(dc)-bitmap->height)/2;

	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);
	MGL_setColor(MGL_BLUE);

	/* Put the image onto the display device context. */
	for (i = 0; i < 10; i++) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmap(dc,x,y,bitmap,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapDemo2(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmap (Non-Monochrome Image) Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setClipRegion(region);

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadBitmap("frog.bmp",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	/* Justify the image that will be put on the screen */
	x = (MGL_sizex(dc)-bitmap->width)/2;
	y = (MGL_sizey(dc)-bitmap->height)/2;

	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmap(dc,x,y,bitmap,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapDemo3(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmap (Translated Image) Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setClipRegion(region);

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadBitmap("frog.bmp",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Justify the image that will be put on the screen */
	x = (MGL_sizex(dc)-bitmap->width)/2;
	y = (MGL_sizey(dc)-bitmap->height)/2;

	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmap(dc,x,y,bitmap,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapSectionDemo(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapSection Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapSection(dc,0,0,bitmap->width/2,bitmap->height/2,x,y,
			bitmap,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	/* Pause until the user hits a key or presses a mouse button. */
    return(pause());
}

ibool bitmapSectionDemo2(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapSection Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapSection(dc,0,0,bitmap->width/2,bitmap->height/2,x,y,
			bitmap,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    return(pause());
}

ibool bitmapTransDemo(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapSrcTrans Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	/* Load a bitmap and the palette from the image file. */
	if ((bitmap = MGL_loadBitmap("frog.bmp",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	transparent = *((color_t*)bitmap->surface);

	MGL_setClipRegion(region);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapSrcTrans(dc,x,y,bitmap,transparent,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapTransDemo2(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapDstTrans Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Load a bitmap and the palette from the image file. */
	if ((bitmap = MGL_loadBitmap("frog.bmp",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	transparent = *((color_t*)bitmap->surface);
	MGL_setBackColor(transparent);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapDstTrans(dc,x,y,bitmap,transparent,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapTransSectionDemo(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;
	color_t transparent;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapSrcTransSection Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	/* Get the transparent color from the bitmap's surface */
	transparent = *((color_t*)bitmap->surface);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapSrcTransSection(dc,0,0,bitmap->width/2,
			bitmap->height/2,x,y,bitmap,transparent,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while (!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapTransSectionDemo2(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapDstTransSection Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Load a pcx and the palette from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();

	MGL_setClipRegion(region);

	/* Put the image onto the display device context. */
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapDstTransSection(dc,0,0,bitmap->width/2,
			bitmap->height/2,x,y,bitmap,MGL_BLUE,MGL_REPLACE_MODE);
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

	/* Pause until the user hits a key or presses a mouse button. */
    while (!checkEvent()) {}
	/* Reset the Ddefault Palette */
	MGL_setDefaultPalette(dc);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapMaskDemo(MGLDC *dc, region_t *region)
{
	int i,x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putBitmapMask Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Load a pcx from the image file. */
	if ((bitmap = (bitmap_t *)MGL_loadPNG("cow-1.png",false)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);
	MGL_setClipRegion(region);
	for (i = 0; i < 25; i++) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putBitmapMask(dc,x,y,bitmap,MGL_GREEN,MGL_REPLACE_MODE);
		}

	defaultAttributes(dc);
    return(pause());
}

ibool putIconDemo(MGLDC *dc, region_t *region)
{
	int x,y,maxx,maxy;
	icon_t *icon = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_putIcon Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	/* Load the icon. */
	if ((icon = MGL_loadIcon("skull.ico",false)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);
	MGL_setClipRegion(region);
	MGL_setColor(MGL_GREEN);
	while (!checkEvent()) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		MGL_putIcon(dc,x,y,icon);
		}

	defaultAttributes(dc);
    return(pause());
}

ibool glyphDemo(MGLDC *dc, region_t *region)
{
	int i,x,y,maxx,maxy,idx;
	font_t *font = NULL;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_drawGlyph Demonstration");
	statusLine("Press any key to continue, ESC to Abort");
	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_BLACK);
	MGL_drawRegion(0,0,region);
	MGL_setClipRegion(region);
	MGL_setColor(MGL_RED);

	font = MGL_loadFont("MVGLYPH0.FNT");
	MGL_useFont(font);
	maxx = MGL_maxx();
	maxy = MGL_maxy();

	for (i = 0; i < 1024; i++) {
		x = MGL_random(maxx+1);
		y = MGL_random(maxy+1);
		idx = MGL_random(16);
		MGL_drawGlyph(font,x,y,idx);
		}

	/* Unload the font from memory */
	MGL_useFont(defFont);
	MGL_unloadFont(font);

	defaultAttributes(dc);
    return(pause());

}

ibool ellipseDemo(MGLDC *dc, region_t *region)
{
	int maxx,maxy;
	rect_t  r;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_ellipse Demonstration");
	statusLine("Press any key to start random test, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setClipRegion(region);
	MGL_setPenStyle(MGL_BITMAP_SOLID);
	while (!checkEvent()) {
		r.left = MGL_random(maxx-100);
		r.top = MGL_random(maxy-100);
		r.right = r.left + MGL_random(100);
		r.bottom = r.top + MGL_random(100);
		MGL_setPenSize(MGL_random(4)+1,MGL_random(4)+1);

		MGL_setColor(randomColor());
		MGL_ellipse(r);
		}

	defaultAttributes(dc);
    return(pause());
}

ibool filledEllipseDemo(MGLDC *dc, region_t *region)
{
	int val,maxx,maxy;
	rect_t  r;

	/* Display title message at the top of the window. */
	mainWindow(dc,"MGL_fillEllipse Demonstration");
	statusLine("Press any key to start random test, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setClipRegion(region);
	MGL_setPenStyle(MGL_BITMAP_SOLID);
	while (!checkEvent()) {
		r.left = MGL_random(maxx-100);
		r.top = MGL_random(maxy-100);
		r.right = r.left + MGL_random(100);
		r.bottom = r.top + MGL_random(100);

		MGL_setColor(randomColor());
		MGL_setBackColor(randomColor());

		if ((val = MGL_random(5)) == 0) {
			MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
			MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
			MGL_usePenBitmapPattern(0);
			}
		else if (val == 1) {
			MGL_setPenStyle(MGL_BITMAP_OPAQUE);
			MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
			MGL_usePenBitmapPattern(0);
			}
		else {
			MGL_setPenStyle(MGL_BITMAP_SOLID);
			}
		MGL_fillEllipse(r);
		}

	defaultAttributes(dc);
    return(pause());
}

ibool ellipseArcDemo(MGLDC *dc, region_t *region)
/****************************************************************************
*
* Function:     arcDemo
* Parameters:   dc  - Device context
*
* Description:  Display a random pattern of elliptical arc's on the screen
*               until the user hits a key.
*
****************************************************************************/
{
	int     maxx,maxy,startAngle,endAngle;
	rect_t  r;

	mainWindow(dc,"MGL_ellipseArc Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setClipRegion(region);
	MGL_setPenStyle(MGL_BITMAP_SOLID);
	while (!checkEvent()) {
		r.left = MGL_random(maxx-100);
		r.top = MGL_random(maxy-100);
		r.right = r.left + MGL_random(100);
		r.bottom = r.top + MGL_random(100);
		startAngle = MGL_random(360);
		endAngle = MGL_random(360);
		MGL_setPenSize(MGL_random(4)+1,MGL_random(4)+1);

		MGL_setColor(randomColor());
		MGL_ellipseArc(r,startAngle,endAngle);
		}

	defaultAttributes(dc);
    return(pause());
}


ibool filledEllipseArcDemo(MGLDC *dc, region_t *region)
/****************************************************************************
*
* Function:     arcDemo
* Parameters:   dc  - Device context
*
* Description:  Display a random pattern of elliptical arc's on the screen
*               until the user hits a key.
*
****************************************************************************/
{
	int     val,maxx,maxy,startAngle,endAngle;
	rect_t  r;

	mainWindow(dc,"MGL_fillEllipseArc Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();

	MGL_setClipRegion(region);
	MGL_setPenStyle(MGL_BITMAP_SOLID);
	while (!checkEvent()) {
		r.left = MGL_random(maxx-100);
		r.top = MGL_random(maxy-100);
		r.right = r.left + MGL_random(100);
		r.bottom = r.top + MGL_random(100);
		startAngle = MGL_random(360);
		endAngle = MGL_random(360);

		MGL_setColor(randomColor());
		MGL_setBackColor(randomColor());

		if ((val = MGL_random(5)) == 0) {
            MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
			MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
			MGL_usePenBitmapPattern(0);
			}
        else if (val == 1) {
			MGL_setPenStyle(MGL_BITMAP_OPAQUE);
			MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
			MGL_usePenBitmapPattern(0);
			}
		else {
			MGL_setPenStyle(MGL_BITMAP_SOLID);
			}
		MGL_fillEllipseArc(r,startAngle,endAngle);
		}

	defaultAttributes(dc);
    return(pause());
}

ibool stretchBitmapDemo(MGLDC *dc, region_t * region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	mainWindow(dc,"MGL_stretchBitmap Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();
	x=maxx/2,y=maxy/2;

	MGL_setClipRegion(region);

	/* Load a bitmap and the palette from the image file. */
	if ((bitmap = MGL_loadBitmap(IMAGE_NAME,true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the bitmap */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);

	while ((x<maxx) && (y<maxy) && (!checkEvent())) {
		MGL_stretchBitmap(dc,maxx-x,maxy-y,x,y,bitmap,MGL_REPLACE_MODE);
		x += 1;
		y += 1;
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

    return(pause());
}

ibool stretchBitmapSectionDemo(MGLDC *dc, region_t * region)
{
	int x,y,maxx,maxy;
	bitmap_t *bitmap = NULL;

	mainWindow(dc,"MGL_stretchBitmapSection Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();
	x=maxx/2,y=maxy/2;

	MGL_setClipRegion(region);

	/* Load a bitmap and the palette from the image file. */
	if ((bitmap = MGL_loadBitmap(IMAGE_NAME,true)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the bitmap */
	MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);

	while ((x<maxx) && (y<maxy) && (!checkEvent())) {
		MGL_stretchBitmapSection(dc,0,0,bitmap->width/2,bitmap->height/2,
			maxx-x,maxy-y,x,y,bitmap,MGL_REPLACE_MODE);
		x += 1;
		y += 1;
		}

	/* Remove all bitmaps from memory. */
	MGL_unloadBitmap(bitmap);

    return(pause());
}

ibool stretchBltDemo(MGLDC *dc, region_t * region)
{
	MGLDC *memdc;
	int x,y,maxx,maxy;
	int width,height,depth;
	pixel_format_t pf;
	palette_t pal[256];

	mainWindow(dc,"MGL_stretchBlt (Memory DC) Demonstration");
	statusLine("Press any key to continue, ESC to Abort");

	maxx = MGL_maxx();
	maxy = MGL_maxy();
	x=maxx/2,y=maxy/2;

	/* Get image information */
	MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf);

	/* Create a memory device context. */
	if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Load a bitmap into the memory device context. The palette gets
	 * loaded into the memory device context as well.
	 */
	if (MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true) == NULL)
		MGL_fatalError(MGL_errorMsg(MGL_result()));

	/* Set the display device context with the palette from the
	 * memory device context.
	 */
	MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
	MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
	MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);

	MGL_setClipRegion(region);

	MGL_setBackColor(MGL_BLUE);
	MGL_clearViewport();
	MGL_setColor(MGL_RED);
	MGL_drawRegion(0,0,region);

	/* Put the image onto the display device context. */
	while ((x<maxx) && (y<maxy) && (!checkEvent())) {
		MGL_stretchBltCoord(dc,memdc,0,0,width,height,maxx-x,maxy-y,x,y,MGL_REPLACE_MODE);
		x += 1;
		y += 1;
		}

	/* Remove all device contexts from memory. */
	MGL_destroyDC(memdc);

    return(pause());
}

void demo(MGLDC *dc)
{
	region_t 	*clipRgn,*region2;
    ibool go = true;
	/* Create the clip region */
	clipRgn = MGL_rgnSolidRectCoord(50,50,300,280);
	region2 = MGL_rgnSolidRectCoord(200,150,440,440);
	MGL_unionRegion(clipRgn, region2);
	region2 = MGL_rgnSolidRectCoord(340,50,610,280);
	MGL_unionRegion(clipRgn, region2);

/*	if (MGL_getBitsPerPixel(dc) <= 8) MGL_setColor(2);
	else MGL_setColorRGB(0,255,0);
	MGL_drawRegion(0,0,clipRgn);*/
          
    if (go) go = rectTest(dc,clipRgn);
    if (go) go = lineTest(dc,clipRgn);
    if (go) go = pixelDemo(dc,clipRgn);
    if (go) go = sysBltDemo(dc,clipRgn);
    if (go) go = screenBltDemo(dc,clipRgn);
    if (go) go = offScreenBltDemo(dc,clipRgn);
    if (go) go = srcBltDemo(dc,clipRgn);
    if (go) go = srcTranslationBltDemo(dc,clipRgn);
    if (go) go = dstBltDemo(dc,clipRgn);
    if (go) go = dstTranslationBltDemo(dc,clipRgn);
    if (go) go = srcTransOffBltDemo(dc,clipRgn);
    if (go) go = dstTransOffBltDemo(dc,clipRgn);
    if (go) go = srcTransBltDemo(dc,clipRgn);
    if (go) go = dstTransBltDemo(dc,clipRgn);
    if (go) go = linBltDemo(dc,clipRgn);
    if (go) go = srcTransLinBltDemo(dc,clipRgn);
    if (go) go = dstTransLinBltDemo(dc,clipRgn);
    if (go) go = textDemo(dc,clipRgn);
    if (go) go = monoImageDemo(dc,clipRgn);
    if (go) go = bitmapDemo1(dc,clipRgn);
    if (go) go = bitmapDemo2(dc,clipRgn);
    if (go) go = bitmapDemo3(dc,clipRgn);
    if (go) go = bitmapSectionDemo(dc,clipRgn);
    if (go) go = bitmapSectionDemo2(dc,clipRgn);
    if (go) go = bitmapTransDemo(dc,clipRgn);
    if (go) go = bitmapTransDemo2(dc,clipRgn);
    if (go) go = bitmapTransSectionDemo(dc,clipRgn);
    if (go) go = bitmapTransSectionDemo2(dc,clipRgn);
    if (go) go = bitmapMaskDemo(dc,clipRgn);
    if (go) go = putIconDemo(dc,clipRgn);
    if (go) go = glyphDemo(dc,clipRgn);
    if (go) go = ellipseDemo(dc,clipRgn);
    if (go) go = filledEllipseDemo(dc,clipRgn);
    if (go) go = ellipseArcDemo(dc,clipRgn);
    if (go) go = filledEllipseArcDemo(dc,clipRgn);
    if (go) go = stretchBitmapDemo(dc,clipRgn);
    if (go) go = stretchBitmapSectionDemo(dc,clipRgn);
    if (go) go = stretchBltDemo(dc,clipRgn);
} 
 
// TODO: Need to ensure drawRegion is properly clipped also!
// TODO: Need to add code to test for vector font clipping!
// TODO: Need to add code to test for UniCode text clipping!
// TODO: Need to add code to test for polygon clipping!

// TODO: Need to add code to check fat lines with clipping!!

// TODO: Need to add code to test 1bpp and 4bpp bitmap blitting with
//		 clipping!
