This is nasm.info, produced by Makeinfo version 3.12f from nasmdoc.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* NASM: (nasm).                The Netwide Assembler for x86.
END-INFO-DIR-ENTRY


   This file documents NASM, the Netwide Assembler: an assembler
targetting the Intel x86 series of processors, with portable source.

   Copyright 1997 Simon Tatham

   All rights reserved. This document is redistributable under the
licence given in the file "Licence" distributed in the NASM archive.


File: nasm.info,  Node: Section A.80,  Next: Section A.81,  Prev: Section A.79,  Up: Appendix A

A.80. `INSB', `INSW', `INSD': Input String from I/O Port
********************************************************

     INSB                          ; 6C                   [186]
     INSW                          ; o16 6D               [186]
     INSD                          ; o32 6D               [386]

   `INSB' inputs a byte from the I/O port specified in `DX' and stores
it at `[ES:DI]' or `[ES:EDI]'. It then increments or decrements
(depending on the direction flag: increments if the flag is clear,
decrements if it is set) `DI' or `EDI'.

   The register used is `DI' if the address size is 16 bits, and `EDI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   Segment override prefixes have no effect for this instruction: the
use of `ES' for the load from `[DI]' or `[EDI]' cannot be overridden.

   `INSW' and `INSD' work in the same way, but they input a word or a
doubleword instead of a byte, and increment or decrement the addressing
register by 2 or 4 instead of 1.

   The `REP' prefix may be used to repeat the instruction `CX' (or
`ECX' - again, the address size chooses which) times.

   See also `OUTSB', `OUTSW' and `OUTSD' (*Note Section A.112::).


File: nasm.info,  Node: Section A.81,  Next: Section A.82,  Prev: Section A.80,  Up: Appendix A

A.81. `INT': Software Interrupt
*******************************

     INT imm8                      ; CD ib                [8086]

   `INT' causes a software interrupt through a specified vector number
from 0 to 255.

   The code generated by the `INT' instruction is always two bytes long:
although there are short forms for some `INT' instructions, NASM does
not generate them when it sees the `INT' mnemonic. In order to generate
single-byte breakpoint instructions, use the `INT3' or `INT1'
instructions (see *Note Section A.82::) instead.


File: nasm.info,  Node: Section A.82,  Next: Section A.83,  Prev: Section A.81,  Up: Appendix A

A.82. `INT3', `INT1', `ICEBP', `INT01': Breakpoints
***************************************************

     INT1                          ; F1                   [P6]
     ICEBP                         ; F1                   [P6]
     INT01                         ; F1                   [P6]

     INT3                          ; CC                   [8086]

   `INT1' and `INT3' are short one-byte forms of the instructions `INT
1' and `INT 3' (see *Note Section A.81::). They perform a similar
function to their longer counterparts, but take up less code space.
They are used as breakpoints by debuggers.

   `INT1', and its alternative synonyms `INT01' and `ICEBP', is an
instruction used by in-circuit emulators (ICEs). It is present, though
not documented, on some processors down to the 286, but is only
documented for the Pentium Pro. `INT3' is the instruction normally used
as a breakpoint by debuggers.

   `INT3' is not precisely equivalent to `INT 3': the short form, since
it is designed to be used as a breakpoint, bypasses the normal IOPL
checks in virtual-8086 mode, and also does not go through interrupt
redirection.


File: nasm.info,  Node: Section A.83,  Next: Section A.84,  Prev: Section A.82,  Up: Appendix A

A.83. `INTO': Interrupt if Overflow
***********************************

     INTO                          ; CE                   [8086]

   `INTO' performs an `INT 4' software interrupt (see *Note Section
A.81::) if and only if the overflow flag is set.


File: nasm.info,  Node: Section A.84,  Next: Section A.85,  Prev: Section A.83,  Up: Appendix A

A.84. `INVD': Invalidate Internal Caches
****************************************

     INVD                          ; 0F 08                [486]

   `INVD' invalidates and empties the processor's internal caches, and
causes the processor to instruct external caches to do the same. It does
not write the contents of the caches back to memory first: any modified
data held in the caches will be lost. To write the data back first, use
`WBINVD' (*Note Section A.164::).


File: nasm.info,  Node: Section A.85,  Next: Section A.86,  Prev: Section A.84,  Up: Appendix A

A.85. `INVLPG': Invalidate TLB Entry
************************************

     INVLPG mem                    ; 0F 01 /0             [486]

   `INVLPG' invalidates the translation lookahead buffer (TLB) entry
associated with the supplied memory address.


File: nasm.info,  Node: Section A.86,  Next: Section A.87,  Prev: Section A.85,  Up: Appendix A

A.86. `IRET', `IRETW', `IRETD': Return from Interrupt
*****************************************************

     IRET                          ; CF                   [8086]
     IRETW                         ; o16 CF               [8086]
     IRETD                         ; o32 CF               [386]

   `IRET' returns from an interrupt (hardware or software) by means of
popping `IP' (or `EIP'), `CS' and the flags off the stack and then
continuing execution from the new `CS:IP'.

   `IRETW' pops `IP', `CS' and the flags as 2 bytes each, taking 6
bytes off the stack in total. `IRETD' pops `EIP' as 4 bytes, pops a
further 4 bytes of which the top two are discarded and the bottom two
go into `CS', and pops the flags as 4 bytes as well, taking 12 bytes
off the stack.

   `IRET' is a shorthand for either `IRETW' or `IRETD', depending on
the default `BITS' setting at the time.


File: nasm.info,  Node: Section A.87,  Next: Section A.88,  Prev: Section A.86,  Up: Appendix A

A.87. `JCXZ', `JECXZ': Jump if CX/ECX Zero
******************************************

     JCXZ imm                      ; o16 E3 rb            [8086]
     JECXZ imm                     ; o32 E3 rb            [386]

   `JCXZ' performs a short jump (with maximum range 128 bytes) if and
only if the contents of the `CX' register is 0. `JECXZ' does the same
thing, but with `ECX'.


File: nasm.info,  Node: Section A.88,  Next: Section A.89,  Prev: Section A.87,  Up: Appendix A

A.88. `JMP': Jump
*****************

     JMP imm                       ; E9 rw/rd             [8086]
     JMP SHORT imm                 ; EB rb                [8086]
     JMP imm:imm16                 ; o16 EA iw iw         [8086]
     JMP imm:imm32                 ; o32 EA id iw         [386]
     JMP FAR mem                   ; o16 FF /5            [8086]
     JMP FAR mem                   ; o32 FF /5            [386]
     JMP r/m16                     ; o16 FF /4            [8086]
     JMP r/m32                     ; o32 FF /4            [386]

   `JMP' jumps to a given address. The address may be specified as an
absolute segment and offset, or as a relative jump within the current
segment.

   `JMP SHORT imm' has a maximum range of 128 bytes, since the
displacement is specified as only 8 bits, but takes up less code space.
NASM does not choose when to generate `JMP SHORT' for you: you must
explicitly code `SHORT' every time you want a short jump.

   You can choose between the two immediate far jump forms (`JMP
imm:imm') by the use of the `WORD' and `DWORD' keywords: `JMP WORD
0x1234:0x5678') or `JMP DWORD 0x1234:0x56789abc'.

   The `JMP FAR mem' forms execute a far jump by loading the destination
address out of memory. The address loaded consists of 16 or 32 bits of
offset (depending on the operand size), and 16 bits of segment. The
operand size may be overridden using `JMP WORD FAR mem' or `JMP DWORD
FAR mem'.

   The `JMP r/m' forms execute a near jump (within the same segment),
loading the destination address out of memory or out of a register. The
keyword `NEAR' may be specified, for clarity, in these forms, but is
not necessary. Again, operand size can be overridden using `JMP WORD
mem' or `JMP DWORD mem'.

   As a convenience, NASM does not require you to jump to a far symbol
by coding the cumbersome `JMP SEG routine:routine', but instead allows
the easier synonym `JMP FAR routine'.

   The `CALL r/m' forms given above are near calls; NASM will accept the
`NEAR' keyword (e.g. `CALL NEAR [address]'), even though it is not
strictly necessary.


File: nasm.info,  Node: Section A.89,  Next: Section A.90,  Prev: Section A.88,  Up: Appendix A

A.89. `Jcc': Conditional Branch
*******************************

     Jcc imm                       ; 70+cc rb             [8086]
     Jcc NEAR imm                  ; 0F 80+cc rw/rd       [386]

   The conditional jump instructions execute a near (same segment) jump
if and only if their conditions are satisfied. For example, `JNZ' jumps
only if the zero flag is not set.

   The ordinary form of the instructions has only a 128-byte range; the
`NEAR' form is a 386 extension to the instruction set, and can span the
full size of a segment. NASM will not override your choice of jump
instruction: if you want `Jcc NEAR', you have to use the `NEAR' keyword.

   The `SHORT' keyword is allowed on the first form of the instruction,
for clarity, but is not necessary.


File: nasm.info,  Node: Section A.90,  Next: Section A.91,  Prev: Section A.89,  Up: Appendix A

A.90. `LAHF': Load AH from Flags
********************************

     LAHF                          ; 9F                   [8086]

   `LAHF' sets the `AH' register according to the contents of the low
byte of the flags word. See also `SAHF' (*Note Section A.145::).


File: nasm.info,  Node: Section A.91,  Next: Section A.92,  Prev: Section A.90,  Up: Appendix A

A.91. `LAR': Load Access Rights
*******************************

     LAR reg16,r/m16               ; o16 0F 02 /r         [286,PRIV]
     LAR reg32,r/m32               ; o32 0F 02 /r         [286,PRIV]

   `LAR' takes the segment selector specified by its source (second)
operand, finds the corresponding segment descriptor in the GDT or LDT,
and loads the access-rights byte of the descriptor into its destination
(first) operand.


File: nasm.info,  Node: Section A.92,  Next: Section A.93,  Prev: Section A.91,  Up: Appendix A

A.92. `LDS', `LES', `LFS', `LGS', `LSS': Load Far Pointer
*********************************************************

     LDS reg16,mem                 ; o16 C5 /r            [8086]
     LDS reg32,mem                 ; o32 C5 /r            [8086]

     LES reg16,mem                 ; o16 C4 /r            [8086]
     LES reg32,mem                 ; o32 C4 /r            [8086]

     LFS reg16,mem                 ; o16 0F B4 /r         [386]
     LFS reg32,mem                 ; o32 0F B4 /r         [386]

     LGS reg16,mem                 ; o16 0F B5 /r         [386]
     LGS reg32,mem                 ; o32 0F B5 /r         [386]

     LSS reg16,mem                 ; o16 0F B2 /r         [386]
     LSS reg32,mem                 ; o32 0F B2 /r         [386]

   These instructions load an entire far pointer (16 or 32 bits of
offset, plus 16 bits of segment) out of memory in one go. `LDS', for
example, loads 16 or 32 bits from the given memory address into the
given register (depending on the size of the register), then loads the
_next_ 16 bits from memory into `DS'. `LES', `LFS', `LGS' and `LSS'
work in the same way but use the other segment registers.


File: nasm.info,  Node: Section A.93,  Next: Section A.94,  Prev: Section A.92,  Up: Appendix A

A.93. `LEA': Load Effective Address
***********************************

     LEA reg16,mem                 ; o16 8D /r            [8086]
     LEA reg32,mem                 ; o32 8D /r            [8086]

   `LEA', despite its syntax, does not access memory. It calculates the
effective address specified by its second operand as if it were going to
load or store data from it, but instead it stores the calculated address
into the register specified by its first operand. This can be used to
perform quite complex calculations (e.g. `LEA EAX,[EBX+ECX*4+100]') in
one instruction.

   `LEA', despite being a purely arithmetic instruction which accesses
no memory, still requires square brackets around its second operand, as
if it were a memory reference.


File: nasm.info,  Node: Section A.94,  Next: Section A.95,  Prev: Section A.93,  Up: Appendix A

A.94. `LEAVE': Destroy Stack Frame
**********************************

     LEAVE                         ; C9                   [186]

   `LEAVE' destroys a stack frame of the form created by the `ENTER'
instruction (see *Note Section A.27::). It is functionally equivalent to
`MOV ESP,EBP' followed by `POP EBP' (or `MOV SP,BP' followed by `POP
BP' in 16-bit mode).


File: nasm.info,  Node: Section A.95,  Next: Section A.96,  Prev: Section A.94,  Up: Appendix A

A.95. `LGDT', `LIDT', `LLDT': Load Descriptor Tables
****************************************************

     LGDT mem                      ; 0F 01 /2             [286,PRIV]
     LIDT mem                      ; 0F 01 /3             [286,PRIV]
     LLDT r/m16                    ; 0F 00 /2             [286,PRIV]

   `LGDT' and `LIDT' both take a 6-byte memory area as an operand: they
load a 32-bit linear address and a 16-bit size limit from that area (in
the opposite order) into the GDTR (global descriptor table register) or
IDTR (interrupt descriptor table register). These are the only
instructions which directly use _linear_ addresses, rather than
segment/offset pairs.

   `LLDT' takes a segment selector as an operand. The processor looks up
that selector in the GDT and stores the limit and base address given
there into the LDTR (local descriptor table register).

   See also `SGDT', `SIDT' and `SLDT' (*Note Section A.151::).


File: nasm.info,  Node: Section A.96,  Next: Section A.97,  Prev: Section A.95,  Up: Appendix A

A.96. `LMSW': Load/Store Machine Status Word
********************************************

     LMSW r/m16                    ; 0F 01 /6             [286,PRIV]

   `LMSW' loads the bottom four bits of the source operand into the
bottom four bits of the `CR0' control register (or the Machine Status
Word, on 286 processors). See also `SMSW' (*Note Section A.155::).


File: nasm.info,  Node: Section A.97,  Next: Section A.98,  Prev: Section A.96,  Up: Appendix A

A.97. `LOADALL', `LOADALL286': Load Processor State
***************************************************

     LOADALL                       ; 0F 07                [386,UNDOC]
     LOADALL286                    ; 0F 05                [286,UNDOC]

   This instruction, in its two different-opcode forms, is apparently
supported on most 286 processors, some 386 and possibly some 486. The
opcode differs between the 286 and the 386.

   The function of the instruction is to load all information relating
to the state of the processor out of a block of memory: on the 286,
this block is located implicitly at absolute address `0x800', and on
the 386 and 486 it is at `[ES:EDI]'.


File: nasm.info,  Node: Section A.98,  Next: Section A.99,  Prev: Section A.97,  Up: Appendix A

A.98. `LODSB', `LODSW', `LODSD': Load from String
*************************************************

     LODSB                         ; AC                   [8086]
     LODSW                         ; o16 AD               [8086]
     LODSD                         ; o32 AD               [386]

   `LODSB' loads a byte from `[DS:SI]' or `[DS:ESI]' into `AL'. It then
increments or decrements (depending on the direction flag: increments
if the flag is clear, decrements if it is set) `SI' or `ESI'.

   The register used is `SI' if the address size is 16 bits, and `ESI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`es lodsb').

   `LODSW' and `LODSD' work in the same way, but they load a word or a
doubleword instead of a byte, and increment or decrement the addressing
registers by 2 or 4 instead of 1.


File: nasm.info,  Node: Section A.99,  Next: Section A.100,  Prev: Section A.98,  Up: Appendix A

A.99. `LOOP', `LOOPE', `LOOPZ', `LOOPNE', `LOOPNZ': Loop with Counter
*********************************************************************

     LOOP imm                      ; E2 rb                [8086]
     LOOP imm,CX                   ; a16 E2 rb            [8086]
     LOOP imm,ECX                  ; a32 E2 rb            [386]

     LOOPE imm                     ; E1 rb                [8086]
     LOOPE imm,CX                  ; a16 E1 rb            [8086]
     LOOPE imm,ECX                 ; a32 E1 rb            [386]
     LOOPZ imm                     ; E1 rb                [8086]
     LOOPZ imm,CX                  ; a16 E1 rb            [8086]
     LOOPZ imm,ECX                 ; a32 E1 rb            [386]

     LOOPNE imm                    ; E0 rb                [8086]
     LOOPNE imm,CX                 ; a16 E0 rb            [8086]
     LOOPNE imm,ECX                ; a32 E0 rb            [386]
     LOOPNZ imm                    ; E0 rb                [8086]
     LOOPNZ imm,CX                 ; a16 E0 rb            [8086]
     LOOPNZ imm,ECX                ; a32 E0 rb            [386]

   `LOOP' decrements its counter register (either `CX' or `ECX' - if
one is not specified explicitly, the `BITS' setting dictates which is
used) by one, and if the counter does not become zero as a result of
this operation, it jumps to the given label. The jump has a range of 128
bytes.

   `LOOPE' (or its synonym `LOOPZ') adds the additional condition that
it only jumps if the counter is nonzero _and_ the zero flag is set.
Similarly, `LOOPNE' (and `LOOPNZ') jumps only if the counter is nonzero
and the zero flag is clear.


File: nasm.info,  Node: Section A.100,  Next: Section A.101,  Prev: Section A.99,  Up: Appendix A

A.100. `LSL': Load Segment Limit
********************************

     LSL reg16,r/m16               ; o16 0F 03 /r         [286,PRIV]
     LSL reg32,r/m32               ; o32 0F 03 /r         [286,PRIV]

   `LSL' is given a segment selector in its source (second) operand; it
computes the segment limit value by loading the segment limit field from
the associated segment descriptor in the GDT or LDT. (This involves
shifting left by 12 bits if the segment limit is page-granular, and not
if it is byte-granular; so you end up with a byte limit in either
case.) The segment limit obtained is then loaded into the destination
(first) operand.


File: nasm.info,  Node: Section A.101,  Next: Section A.102,  Prev: Section A.100,  Up: Appendix A

A.101. `LTR': Load Task Register
********************************

     LTR r/m16                     ; 0F 00 /3             [286,PRIV]

   `LTR' looks up the segment base and limit in the GDT or LDT
descriptor specified by the segment selector given as its operand, and
loads them into the Task Register.


File: nasm.info,  Node: Section A.102,  Next: Section A.103,  Prev: Section A.101,  Up: Appendix A

A.102. `MOV': Move Data
***********************

     MOV r/m8,reg8                 ; 88 /r                [8086]
     MOV r/m16,reg16               ; o16 89 /r            [8086]
     MOV r/m32,reg32               ; o32 89 /r            [386]
     MOV reg8,r/m8                 ; 8A /r                [8086]
     MOV reg16,r/m16               ; o16 8B /r            [8086]
     MOV reg32,r/m32               ; o32 8B /r            [386]

     MOV reg8,imm8                 ; B0+r ib              [8086]
     MOV reg16,imm16               ; o16 B8+r iw          [8086]
     MOV reg32,imm32               ; o32 B8+r id          [386]
     MOV r/m8,imm8                 ; C6 /0 ib             [8086]
     MOV r/m16,imm16               ; o16 C7 /0 iw         [8086]
     MOV r/m32,imm32               ; o32 C7 /0 id         [386]

     MOV AL,memoffs8               ; A0 ow/od             [8086]
     MOV AX,memoffs16              ; o16 A1 ow/od         [8086]
     MOV EAX,memoffs32             ; o32 A1 ow/od         [386]
     MOV memoffs8,AL               ; A2 ow/od             [8086]
     MOV memoffs16,AX              ; o16 A3 ow/od         [8086]
     MOV memoffs32,EAX             ; o32 A3 ow/od         [386]

     MOV r/m16,segreg              ; o16 8C /r            [8086]
     MOV r/m32,segreg              ; o32 8C /r            [386]
     MOV segreg,r/m16              ; o16 8E /r            [8086]
     MOV segreg,r/m32              ; o32 8E /r            [386]

     MOV reg32,CR0/2/3/4           ; 0F 20 /r             [386]
     MOV reg32,DR0/1/2/3/6/7       ; 0F 21 /r             [386]
     MOV reg32,TR3/4/5/6/7         ; 0F 24 /r             [386]
     MOV CR0/2/3/4,reg32           ; 0F 22 /r             [386]
     MOV DR0/1/2/3/6/7,reg32       ; 0F 23 /r             [386]
     MOV TR3/4/5/6/7,reg32         ; 0F 26 /r             [386]

   `MOV' copies the contents of its source (second) operand into its
destination (first) operand.

   In all forms of the `MOV' instruction, the two operands are the same
size, except for moving between a segment register and an `r/m32'
operand. These instructions are treated exactly like the corresponding
16- bit equivalent (so that, for example, `MOV DS,EAX' functions
identically to `MOV DS,AX' but saves a prefix when in 32-bit mode),
except that when a segment register is moved into a 32-bit destination,
the top two bytes of the result are undefined.

   `MOV' may not use `CS' as a destination.

   `CR4' is only a supported register on the Pentium and above.


File: nasm.info,  Node: Section A.103,  Next: Section A.104,  Prev: Section A.102,  Up: Appendix A

A.103. `MOVD': Move Doubleword to/from MMX Register
***************************************************

     MOVD mmxreg,r/m32             ; 0F 6E /r             [PENT,MMX]
     MOVD r/m32,mmxreg             ; 0F 7E /r             [PENT,MMX]

   `MOVD' copies 32 bits from its source (second) operand into its
destination (first) operand. When the destination is a 64-bit MMX
register, the top 32 bits are set to zero.


File: nasm.info,  Node: Section A.104,  Next: Section A.105,  Prev: Section A.103,  Up: Appendix A

A.104. `MOVQ': Move Quadword to/from MMX Register
*************************************************

     MOVQ mmxreg,r/m64             ; 0F 6F /r             [PENT,MMX]
     MOVQ r/m64,mmxreg             ; 0F 7F /r             [PENT,MMX]

   `MOVQ' copies 64 bits from its source (second) operand into its
destination (first) operand.


File: nasm.info,  Node: Section A.105,  Next: Section A.106,  Prev: Section A.104,  Up: Appendix A

A.105. `MOVSB', `MOVSW', `MOVSD': Move String
*********************************************

     MOVSB                         ; A4                   [8086]
     MOVSW                         ; o16 A5               [8086]
     MOVSD                         ; o32 A5               [386]

   `MOVSB' copies the byte at `[ES:DI]' or `[ES:EDI]' to `[DS:SI]' or
`[DS:ESI]'. It then increments or decrements (depending on the
direction flag: increments if the flag is clear, decrements if it is
set) `SI' and `DI' (or `ESI' and `EDI').

   The registers used are `SI' and `DI' if the address size is 16 bits,
and `ESI' and `EDI' if it is 32 bits. If you need to use an address
size not equal to the current `BITS' setting, you can use an explicit
`a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`es movsb'). The use of `ES' for the store to `[DI]' or `[EDI]' cannot
be overridden.

   `MOVSW' and `MOVSD' work in the same way, but they copy a word or a
doubleword instead of a byte, and increment or decrement the addressing
registers by 2 or 4 instead of 1.

   The `REP' prefix may be used to repeat the instruction `CX' (or
`ECX' - again, the address size chooses which) times.


File: nasm.info,  Node: Section A.106,  Next: Section A.107,  Prev: Section A.105,  Up: Appendix A

A.106. `MOVSX', `MOVZX': Move Data with Sign or Zero Extend
***********************************************************

     MOVSX reg16,r/m8              ; o16 0F BE /r         [386]
     MOVSX reg32,r/m8              ; o32 0F BE /r         [386]
     MOVSX reg32,r/m16             ; o32 0F BF /r         [386]

     MOVZX reg16,r/m8              ; o16 0F B6 /r         [386]
     MOVZX reg32,r/m8              ; o32 0F B6 /r         [386]
     MOVZX reg32,r/m16             ; o32 0F B7 /r         [386]

   `MOVSX' sign-extends its source (second) operand to the length of its
destination (first) operand, and copies the result into the destination
operand. `MOVZX' does the same, but zero-extends rather than sign-
extending.


File: nasm.info,  Node: Section A.107,  Next: Section A.108,  Prev: Section A.106,  Up: Appendix A

A.107. `MUL': Unsigned Integer Multiply
***************************************

     MUL r/m8                      ; F6 /4                [8086]
     MUL r/m16                     ; o16 F7 /4            [8086]
     MUL r/m32                     ; o32 F7 /4            [386]

   `MUL' performs unsigned integer multiplication. The other operand to
the multiplication, and the destination operand, are implicit, in the
following way:

   * For `MUL r/m8', `AL' is multiplied by the given operand; the
     product is stored in `AX'.

   * For `MUL r/m16', `AX' is multiplied by the given operand; the
     product is stored in `DX:AX'.

   * For `MUL r/m32', `EAX' is multiplied by the given operand; the
     product is stored in `EDX:EAX'.

   Signed integer multiplication is performed by the `IMUL' instruction:
see *Note Section A.77::.


File: nasm.info,  Node: Section A.108,  Next: Section A.109,  Prev: Section A.107,  Up: Appendix A

A.108. `NEG', `NOT': Two's and One's Complement
***********************************************

     NEG r/m8                      ; F6 /3                [8086]
     NEG r/m16                     ; o16 F7 /3            [8086]
     NEG r/m32                     ; o32 F7 /3            [386]

     NOT r/m8                      ; F6 /2                [8086]
     NOT r/m16                     ; o16 F7 /2            [8086]
     NOT r/m32                     ; o32 F7 /2            [386]

   `NEG' replaces the contents of its operand by the two's complement
negation (invert all the bits and then add one) of the original value.
`NOT', similarly, performs one's complement (inverts all the bits).


File: nasm.info,  Node: Section A.109,  Next: Section A.110,  Prev: Section A.108,  Up: Appendix A

A.109. `NOP': No Operation
**************************

     NOP                           ; 90                   [8086]

   `NOP' performs no operation. Its opcode is the same as that generated
by `XCHG AX,AX' or `XCHG EAX,EAX' (depending on the processor mode; see
*Note Section A.168::).


File: nasm.info,  Node: Section A.110,  Next: Section A.111,  Prev: Section A.109,  Up: Appendix A

A.110. `OR': Bitwise OR
***********************

     OR r/m8,reg8                  ; 08 /r                [8086]
     OR r/m16,reg16                ; o16 09 /r            [8086]
     OR r/m32,reg32                ; o32 09 /r            [386]

     OR reg8,r/m8                  ; 0A /r                [8086]
     OR reg16,r/m16                ; o16 0B /r            [8086]
     OR reg32,r/m32                ; o32 0B /r            [386]

     OR r/m8,imm8                  ; 80 /1 ib             [8086]
     OR r/m16,imm16                ; o16 81 /1 iw         [8086]
     OR r/m32,imm32                ; o32 81 /1 id         [386]

     OR r/m16,imm8                 ; o16 83 /1 ib         [8086]
     OR r/m32,imm8                 ; o32 83 /1 ib         [386]

     OR AL,imm8                    ; 0C ib                [8086]
     OR AX,imm16                   ; o16 0D iw            [8086]
     OR EAX,imm32                  ; o32 0D id            [386]

   `OR' performs a bitwise OR operation between its two operands (i.e.
each bit of the result is 1 if and only if at least one of the
corresponding bits of the two inputs was 1), and stores the result in
the destination (first) operand.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.

   The MMX instruction `POR' (see *Note Section A.129::) performs the
same operation on the 64-bit MMX registers.


File: nasm.info,  Node: Section A.111,  Next: Section A.112,  Prev: Section A.110,  Up: Appendix A

A.111. `OUT': Output Data to I/O Port
*************************************

     OUT imm8,AL                   ; E6 ib                [8086]
     OUT imm8,AX                   ; o16 E7 ib            [8086]
     OUT imm8,EAX                  ; o32 E7 ib            [386]
     OUT DX,AL                     ; EE                   [8086]
     OUT DX,AX                     ; o16 EF               [8086]
     OUT DX,EAX                    ; o32 EF               [386]

   `IN' writes the contents of the given source register to the
specified I/O port. The port number may be specified as an immediate
value if it is between 0 and 255, and otherwise must be stored in `DX'.
See also `IN' (*Note Section A.78::).


File: nasm.info,  Node: Section A.112,  Next: Section A.113,  Prev: Section A.111,  Up: Appendix A

A.112. `OUTSB', `OUTSW', `OUTSD': Output String to I/O Port
***********************************************************

     OUTSB                         ; 6E                   [186]

     OUTSW                         ; o16 6F               [186]

     OUTSD                         ; o32 6F               [386]

   `OUTSB' loads a byte from `[DS:SI]' or `[DS:ESI]' and writes it to
the I/O port specified in `DX'. It then increments or decrements
(depending on the direction flag: increments if the flag is clear,
decrements if it is set) `SI' or `ESI'.

   The register used is `SI' if the address size is 16 bits, and `ESI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`es outsb').

   `OUTSW' and `OUTSD' work in the same way, but they output a word or
a doubleword instead of a byte, and increment or decrement the
addressing registers by 2 or 4 instead of 1.

   The `REP' prefix may be used to repeat the instruction `CX' (or
`ECX' - again, the address size chooses which) times.


File: nasm.info,  Node: Section A.113,  Next: Section A.114,  Prev: Section A.112,  Up: Appendix A

A.113. `PACKSSDW', `PACKSSWB', `PACKUSWB': Pack Data
****************************************************

     PACKSSDW mmxreg,r/m64         ; 0F 6B /r             [PENT,MMX]
     PACKSSWB mmxreg,r/m64         ; 0F 63 /r             [PENT,MMX]
     PACKUSWB mmxreg,r/m64         ; 0F 67 /r             [PENT,MMX]

   All these instructions start by forming a notional 128-bit word by
placing the source (second) operand on the left of the destination
(first) operand.  `PACKSSDW' then splits this 128-bit word into four
doublewords, converts each to a word, and loads them side by side into
the destination register; `PACKSSWB' and `PACKUSWB' both split the
128-bit word into eight words, converts each to a byte, and loads
_those_ side by side into the destination register.

   `PACKSSDW' and `PACKSSWB' perform signed saturation when reducing
the length of numbers: if the number is too large to fit into the
reduced space, they replace it by the largest signed number (`7FFFh' or
`7Fh') that _will_ fit, and if it is too small then they replace it by
the smallest signed number (`8000h' or `80h') that will fit. `PACKUSWB'
performs unsigned saturation: it treats its input as unsigned, and
replaces it by the largest unsigned number that will fit.


File: nasm.info,  Node: Section A.114,  Next: Section A.115,  Prev: Section A.113,  Up: Appendix A

A.114. `PADDxx': MMX Packed Addition
************************************

     PADDB mmxreg,r/m64            ; 0F FC /r             [PENT,MMX]
     PADDW mmxreg,r/m64            ; 0F FD /r             [PENT,MMX]
     PADDD mmxreg,r/m64            ; 0F FE /r             [PENT,MMX]

     PADDSB mmxreg,r/m64           ; 0F EC /r             [PENT,MMX]
     PADDSW mmxreg,r/m64           ; 0F ED /r             [PENT,MMX]

     PADDUSB mmxreg,r/m64          ; 0F DC /r             [PENT,MMX]
     PADDUSW mmxreg,r/m64          ; 0F DD /r             [PENT,MMX]

   `PADDxx' all perform packed addition between their two 64-bit
operands, storing the result in the destination (first) operand. The
`PADDxB' forms treat the 64-bit operands as vectors of eight bytes, and
add each byte individually; `PADDxW' treat the operands as vectors of
four words; and `PADDD' treats its operands as vectors of two
doublewords.

   `PADDSB' and `PADDSW' perform signed saturation on the sum of each
pair of bytes or words: if the result of an addition is too large or
too small to fit into a signed byte or word result, it is clipped
(saturated) to the largest or smallest value which _will_ fit.
`PADDUSB' and `PADDUSW' similarly perform unsigned saturation, clipping
to `0FFh' or `0FFFFh' if the result is larger than that.


File: nasm.info,  Node: Section A.115,  Next: Section A.116,  Prev: Section A.114,  Up: Appendix A

A.115. `PADDSIW': MMX Packed Addition to Implicit Destination
*************************************************************

     PADDSIW mmxreg,r/m64          ; 0F 51 /r             [CYRIX,MMX]

   `PADDSIW', specific to the Cyrix extensions to the MMX instruction
set, performs the same function as `PADDSW', except that the result is
not placed in the register specified by the first operand, but instead
in the register whose number differs from the first operand only in the
last bit. So `PADDSIW MM0,MM2' would put the result in `MM1', but
`PADDSIW MM1,MM2' would put the result in `MM0'.


File: nasm.info,  Node: Section A.116,  Next: Section A.117,  Prev: Section A.115,  Up: Appendix A

A.116. `PAND', `PANDN': MMX Bitwise AND and AND-NOT
***************************************************

     PAND mmxreg,r/m64             ; 0F DB /r             [PENT,MMX]
     PANDN mmxreg,r/m64            ; 0F DF /r             [PENT,MMX]

   `PAND' performs a bitwise AND operation between its two operands
(i.e.  each bit of the result is 1 if and only if the corresponding
bits of the two inputs were both 1), and stores the result in the
destination (first) operand.

   `PANDN' performs the same operation, but performs a one's complement
operation on the destination (first) operand first.


File: nasm.info,  Node: Section A.117,  Next: Section A.118,  Prev: Section A.116,  Up: Appendix A

A.117. `PAVEB': MMX Packed Average
**********************************

     PAVEB mmxreg,r/m64            ; 0F 50 /r             [CYRIX,MMX]

   `PAVEB', specific to the Cyrix MMX extensions, treats its two
operands as vectors of eight unsigned bytes, and calculates the average
of the corresponding bytes in the operands. The resulting vector of
eight averages is stored in the first operand.


File: nasm.info,  Node: Section A.118,  Next: Section A.119,  Prev: Section A.117,  Up: Appendix A

A.118. `PCMPxx': MMX Packed Comparison
**************************************

     PCMPEQB mmxreg,r/m64          ; 0F 74 /r             [PENT,MMX]
     PCMPEQW mmxreg,r/m64          ; 0F 75 /r             [PENT,MMX]
     PCMPEQD mmxreg,r/m64          ; 0F 76 /r             [PENT,MMX]

     PCMPGTB mmxreg,r/m64          ; 0F 64 /r             [PENT,MMX]
     PCMPGTW mmxreg,r/m64          ; 0F 65 /r             [PENT,MMX]
     PCMPGTD mmxreg,r/m64          ; 0F 66 /r             [PENT,MMX]

   The `PCMPxx' instructions all treat their operands as vectors of
bytes, words, or doublewords; corresponding elements of the source and
destination are compared, and the corresponding element of the
destination (first) operand is set to all zeros or all ones depending
on the result of the comparison.

   `PCMPxxB' treats the operands as vectors of eight bytes, `PCMPxxW'
treats them as vectors of four words, and `PCMPxxD' as two doublewords.

   `PCMPEQx' sets the corresponding element of the destination operand
to all ones if the two elements compared are equal; `PCMPGTx' sets the
destination element to all ones if the element of the first
(destination) operand is greater (treated as a signed integer) than
that of the second (source) operand.


File: nasm.info,  Node: Section A.119,  Next: Section A.120,  Prev: Section A.118,  Up: Appendix A

A.119. `PDISTIB': MMX Packed Distance and Accumulate with Implied Register
**************************************************************************

     PDISTIB mmxreg,mem64          ; 0F 54 /r             [CYRIX,MMX]

   `PDISTIB', specific to the Cyrix MMX extensions, treats its two input
operands as vectors of eight unsigned bytes. For each byte position, it
finds the absolute difference between the bytes in that position in the
two input operands, and adds that value to the byte in the same
position in the implied output register. The addition is saturated to
an unsigned byte in the same way as `PADDUSB'.

   The implied output register is found in the same way as `PADDSIW'
(*Note Section A.115::).

   Note that `PDISTIB' cannot take a register as its second source
operand.


File: nasm.info,  Node: Section A.120,  Next: Section A.121,  Prev: Section A.119,  Up: Appendix A

A.120. `PMACHRIW': MMX Packed Multiply and Accumulate with Rounding
*******************************************************************

     PMACHRIW mmxreg,mem64         ; 0F 5E /r             [CYRIX,MMX]

   `PMACHRIW' acts almost identically to `PMULHRIW' (*Note Section
A.123::), but instead of _storing_ its result in the implied
destination register, it _adds_ its result, as four packed words, to
the implied destination register. No saturation is done: the addition
can wrap around.

   Note that `PMACHRIW' cannot take a register as its second source
operand.


File: nasm.info,  Node: Section A.121,  Next: Section A.122,  Prev: Section A.120,  Up: Appendix A

A.121. `PMADDWD': MMX Packed Multiply and Add
*********************************************

     PMADDWD mmxreg,r/m64          ; 0F F5 /r             [PENT,MMX]

   `PMADDWD' treats its two inputs as vectors of four signed words. It
multiplies corresponding elements of the two operands, giving four
signed doubleword results. The top two of these are added and placed in
the top 32 bits of the destination (first) operand; the bottom two are
added and placed in the bottom 32 bits.


File: nasm.info,  Node: Section A.122,  Next: Section A.123,  Prev: Section A.121,  Up: Appendix A

A.122. `PMAGW': MMX Packed Magnitude
************************************

     PMAGW mmxreg,r/m64            ; 0F 52 /r             [CYRIX,MMX]

   `PMAGW', specific to the Cyrix MMX extensions, treats both its
operands as vectors of four signed words. It compares the absolute
values of the words in corresponding positions, and sets each word of
the destination (first) operand to whichever of the two words in that
position had the larger absolute value.


File: nasm.info,  Node: Section A.123,  Next: Section A.124,  Prev: Section A.122,  Up: Appendix A

A.123. `PMULHRW', `PMULHRIW': MMX Packed Multiply High with Rounding
********************************************************************

     PMULHRW mmxreg,r/m64          ; 0F 59 /r             [CYRIX,MMX]
     PMULHRIW mmxreg,r/m64         ; 0F 5D /r             [CYRIX,MMX]

   These instructions, specific to the Cyrix MMX extensions, treat their
operands as vectors of four signed words. Words in corresponding
positions are multiplied, to give a 32-bit value in which bits 30 and
31 are guaranteed equal. Bits 30 to 15 of this value (bit mask
`0x7FFF8000') are taken and stored in the corresponding position of the
destination operand, after first rounding the low bit (equivalent to
adding `0x4000' before extracting bits 30 to 15).

   For `PMULHRW', the destination operand is the first operand; for
`PMULHRIW' the destination operand is implied by the first operand in
the manner of `PADDSIW' (*Note Section A.115::).


File: nasm.info,  Node: Section A.124,  Next: Section A.125,  Prev: Section A.123,  Up: Appendix A

A.124. `PMULHW', `PMULLW': MMX Packed Multiply
**********************************************

     PMULHW mmxreg,r/m64           ; 0F E5 /r             [PENT,MMX]
     PMULLW mmxreg,r/m64           ; 0F D5 /r             [PENT,MMX]

   `PMULxW' treats its two inputs as vectors of four signed words. It
multiplies corresponding elements of the two operands, giving four
signed doubleword results.

   `PMULHW' then stores the top 16 bits of each doubleword in the
destination (first) operand; `PMULLW' stores the bottom 16 bits of each
doubleword in the destination operand.


File: nasm.info,  Node: Section A.125,  Next: Section A.126,  Prev: Section A.124,  Up: Appendix A

A.125. `PMVccZB': MMX Packed Conditional Move
*********************************************

     PMVZB mmxreg,mem64            ; 0F 58 /r             [CYRIX,MMX]
     PMVNZB mmxreg,mem64           ; 0F 5A /r             [CYRIX,MMX]
     PMVLZB mmxreg,mem64           ; 0F 5B /r             [CYRIX,MMX]
     PMVGEZB mmxreg,mem64          ; 0F 5C /r             [CYRIX,MMX]

   These instructions, specific to the Cyrix MMX extensions, perform
parallel conditional moves. The two input operands are treated as
vectors of eight bytes. Each byte of the destination (first) operand is
either written from the corresponding byte of the source (second)
operand, or left alone, depending on the value of the byte in the
_implied_ operand (specified in the same way as `PADDSIW', in *Note
Section A.115::).

   `PMVZB' performs each move if the corresponding byte in the implied
operand is zero. `PMVNZB' moves if the byte is non-zero. `PMVLZB' moves
if the byte is less than zero, and `PMVGEZB' moves if the byte is
greater than or equal to zero.

   Note that these instructions cannot take a register as their second
source operand.


File: nasm.info,  Node: Section A.126,  Next: Section A.127,  Prev: Section A.125,  Up: Appendix A

A.126. `POP': Pop Data from Stack
*********************************

     POP reg16                     ; o16 58+r             [8086]
     POP reg32                     ; o32 58+r             [386]

     POP r/m16                     ; o16 8F /0            [8086]
     POP r/m32                     ; o32 8F /0            [386]

     POP CS                        ; 0F                   [8086,UNDOC]
     POP DS                        ; 1F                   [8086]
     POP ES                        ; 07                   [8086]
     POP SS                        ; 17                   [8086]
     POP FS                        ; 0F A1                [386]
     POP GS                        ; 0F A9                [386]

   `POP' loads a value from the stack (from `[SS:SP]' or `[SS:ESP]')
and then increments the stack pointer.

   The address-size attribute of the instruction determines whether `SP'
or `ESP' is used as the stack pointer: to deliberately override the
default given by the `BITS' setting, you can use an `a16' or `a32'
prefix.

   The operand-size attribute of the instruction determines whether the
stack pointer is incremented by 2 or 4: this means that segment
register pops in `BITS 32' mode will pop 4 bytes off the stack and
discard the upper two of them. If you need to override that, you can
use an `o16' or `o32' prefix.

   The above opcode listings give two forms for general-purpose
register pop instructions: for example, `POP BX' has the two forms `5B'
and `8F C3'. NASM will always generate the shorter form when given `POP
BX'. NDISASM will disassemble both.

   `POP CS' is not a documented instruction, and is not supported on any
processor above the 8086 (since they use `0Fh' as an opcode prefix for
instruction set extensions). However, at least some 8086 processors do
support it, and so NASM generates it for completeness.


File: nasm.info,  Node: Section A.127,  Next: Section A.128,  Prev: Section A.126,  Up: Appendix A

A.127. `POPAx': Pop All General-Purpose Registers
*************************************************

     POPA                          ; 61                   [186]
     POPAW                         ; o16 61               [186]
     POPAD                         ; o32 61               [386]

   `POPAW' pops a word from the stack into each of, successively, `DI',
`SI', `BP', nothing (it discards a word from the stack which was a
placeholder for `SP'), `BX', `DX', `CX' and `AX'. It is intended to
reverse the operation of `PUSHAW' (see *Note Section A.135::), but it
ignores the value for `SP' that was pushed on the stack by `PUSHAW'.

   `POPAD' pops twice as much data, and places the results in `EDI',
`ESI', `EBP', nothing (placeholder for `ESP'), `EBX', `EDX', `ECX' and
`EAX'. It reverses the operation of `PUSHAD'.

   `POPA' is an alias mnemonic for either `POPAW' or `POPAD', depending
on the current `BITS' setting.

   Note that the registers are popped in reverse order of their numeric
values in opcodes (see *Note Section A.2.1::).


File: nasm.info,  Node: Section A.128,  Next: Section A.129,  Prev: Section A.127,  Up: Appendix A

A.128. `POPFx': Pop Flags Register
**********************************

     POPF                          ; 9D                   [186]
     POPFW                         ; o16 9D               [186]
     POPFD                         ; o32 9D               [386]

   `POPFW' pops a word from the stack and stores it in the bottom 16
bits of the flags register (or the whole flags register, on processors
below a 386). `POPFD' pops a doubleword and stores it in the entire
flags register.

   `POPF' is an alias mnemonic for either `POPFW' or `POPFD', depending
on the current `BITS' setting.

   See also `PUSHF' (*Note Section A.136::).


File: nasm.info,  Node: Section A.129,  Next: Section A.130,  Prev: Section A.128,  Up: Appendix A

A.129. `POR': MMX Bitwise OR
****************************

     POR mmxreg,r/m64              ; 0F EB /r             [PENT,MMX]

   `POR' performs a bitwise OR operation between its two operands (i.e.
each bit of the result is 1 if and only if at least one of the
corresponding bits of the two inputs was 1), and stores the result in
the destination (first) operand.


File: nasm.info,  Node: Section A.130,  Next: Section A.131,  Prev: Section A.129,  Up: Appendix A

A.130. `PSLLx', `PSRLx', `PSRAx': MMX Bit Shifts
************************************************

     PSLLW mmxreg,r/m64            ; 0F F1 /r             [PENT,MMX]
     PSLLW mmxreg,imm8             ; 0F 71 /6 ib          [PENT,MMX]

     PSLLD mmxreg,r/m64            ; 0F F2 /r             [PENT,MMX]
     PSLLD mmxreg,imm8             ; 0F 72 /6 ib          [PENT,MMX]

     PSLLQ mmxreg,r/m64            ; 0F F3 /r             [PENT,MMX]
     PSLLQ mmxreg,imm8             ; 0F 73 /6 ib          [PENT,MMX]

     PSRAW mmxreg,r/m64            ; 0F E1 /r             [PENT,MMX]
     PSRAW mmxreg,imm8             ; 0F 71 /4 ib          [PENT,MMX]

     PSRAD mmxreg,r/m64            ; 0F E2 /r             [PENT,MMX]
     PSRAD mmxreg,imm8             ; 0F 72 /4 ib          [PENT,MMX]

     PSRLW mmxreg,r/m64            ; 0F D1 /r             [PENT,MMX]
     PSRLW mmxreg,imm8             ; 0F 71 /2 ib          [PENT,MMX]

     PSRLD mmxreg,r/m64            ; 0F D2 /r             [PENT,MMX]
     PSRLD mmxreg,imm8             ; 0F 72 /2 ib          [PENT,MMX]

     PSRLQ mmxreg,r/m64            ; 0F D3 /r             [PENT,MMX]
     PSRLQ mmxreg,imm8             ; 0F 73 /2 ib          [PENT,MMX]

   `PSxxQ' perform simple bit shifts on the 64-bit MMX registers: the
destination (first) operand is shifted left or right by the number of
bits given in the source (second) operand, and the vacated bits are
filled in with zeros (for a logical shift) or copies of the original
sign bit (for an arithmetic right shift).

   `PSxxW' and `PSxxD' perform packed bit shifts: the destination
operand is treated as a vector of four words or two doublewords, and
each element is shifted individually, so bits shifted out of one
element do not interfere with empty bits coming into the next.

   `PSLLx' and `PSRLx' perform logical shifts: the vacated bits at one
end of the shifted number are filled with zeros. `PSRAx' performs an
arithmetic right shift: the vacated bits at the top of the shifted
number are filled with copies of the original top (sign) bit.

